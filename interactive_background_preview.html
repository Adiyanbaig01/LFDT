<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Neon Mesh — Interactive Background</title>
        <style>
            :root {
                --bg0: #05060a;
                --bg1: #0a0d16;
                --blue: #1b44ff; /* neon cobalt */
                --node: #5078ff;
            }

            html,
            body {
                height: 100%;
                margin: 0;
                color-scheme: dark;
                background: radial-gradient(
                        1200px circle at 22% 18%,
                        #0b1530,
                        #03040a 60%
                    ),
                    #000;
                overflow: hidden;
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI,
                    Roboto, Inter, Helvetica, Arial, Apple Color Emoji,
                    Segoe UI Emoji;
            }

            canvas#mesh {
                position: fixed;
                inset: 0;
                display: block;
                background: transparent;
            }

            .ui {
                position: fixed;
                left: 1rem;
                bottom: 1rem;
                padding: 0.5rem 0.75rem;
                font-size: 12px;
                border-radius: 12px;
                color: #c8dcff;
                background: rgba(10, 14, 30, 0.35);
                border: 1px solid rgba(80, 110, 255, 0.25);
                backdrop-filter: blur(8px);
                user-select: none;
            }
            .ui input {
                vertical-align: middle;
                margin-right: 0.35rem;
            }

            @media (prefers-reduced-motion: reduce) {
                canvas#mesh {
                    animation: none;
                }
            }
        </style>
    </head>
    <body>
        <canvas id="mesh"></canvas>
        <div class="ui">
            <label
                ><input
                    type="checkbox"
                    id="toggleMotion"
                    checked
                />motion</label
            >
            · hover to interact
        </div>

        <script>
            (() => {
                const canvas = document.getElementById("mesh");
                const ctx = canvas.getContext("2d", { alpha: false });

                // HiDPI scaling
                const DPR = Math.max(
                    1,
                    Math.min(2, window.devicePixelRatio || 1)
                );
                let W, H;

                function resize() {
                    W = canvas.clientWidth = window.innerWidth;
                    H = canvas.clientHeight = window.innerHeight;
                    canvas.width = Math.floor(W * DPR);
                    canvas.height = Math.floor(H * DPR);
                    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
                    buildGradient();
                    seed();
                }

                // Background gradient layers
                let bgGrad;
                function buildGradient() {
                    bgGrad = ctx.createLinearGradient(0, 0, W, H);
                    bgGrad.addColorStop(0, "#02040a");
                    bgGrad.addColorStop(0.35, "#070c1b");
                    bgGrad.addColorStop(1, "#010204");
                }

                const cfg = {
                    speed: 0.2, // base drift
                    density: 18000, // lower -> more points
                    minCount: 90,
                    maxCount: 220,
                    connectDist: 140, // px
                    thickDist: 70,
                    nearMouseBoost: 1.8, // bigger = more connections near cursor
                    triangleDist: 90, // max side length for translucent triangles
                    nodeRadius: 1.6,
                };

                // --- point system ------------------------------------------------------
                class Point {
                    constructor(x, y) {
                        this.x = x;
                        this.y = y;
                        this.vx = (Math.random() - 0.5) * cfg.speed;
                        this.vy = (Math.random() - 0.5) * cfg.speed;
                        this.phase = Math.random() * Math.PI * 2;
                        this.amp = 0.35 + Math.random() * 0.65; // organic wobble strength
                    }
                    step(dt) {
                        this.phase += dt * (0.7 + Math.random() * 0.3) * 0.15;
                        // subtle flow — figure‑eight drift
                        this.vx += Math.cos(this.phase) * 0.004 * this.amp;
                        this.vy +=
                            Math.sin(this.phase * 0.9) * 0.004 * this.amp;

                        // gentle attraction toward cursor
                        if (mouse.active) {
                            const dx = mouse.x - this.x,
                                dy = mouse.y - this.y;
                            const d2 = dx * dx + dy * dy;
                            if (d2 < 180 * 180) {
                                const d = Math.sqrt(d2) + 1e-4;
                                const f = ((180 - d) / 180) * 0.015;
                                this.vx += (dx / d) * f;
                                this.vy += (dy / d) * f;
                            }
                        }

                        this.x += this.vx;
                        this.y += this.vy;

                        // soft wrap
                        const m = 40;
                        if (this.x < -m) this.x = W + m;
                        if (this.x > W + m) this.x = -m;
                        if (this.y < -m) this.y = H + m;
                        if (this.y > H + m) this.y = -m;

                        // prevent runaway
                        this.vx *= 0.995;
                        this.vy *= 0.995;
                    }
                }

                function countForSize() {
                    const n = Math.floor((W * H) / cfg.density);
                    return Math.max(cfg.minCount, Math.min(cfg.maxCount, n));
                }

                let points = [];
                function seed() {
                    const n = countForSize();
                    if (points.length && Math.abs(points.length - n) < 10)
                        return; // keep roughly same size
                    points = [];
                    for (let i = 0; i < n; i++)
                        points.push(
                            new Point(Math.random() * W, Math.random() * H)
                        );
                }

                // Spatial hashing for local neighborhood queries
                const grid = { size: 120, cells: new Map() };
                function rebuildGrid() {
                    grid.cells.clear();
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        const key =
                            ((p.x / grid.size) | 0) +
                            "," +
                            ((p.y / grid.size) | 0);
                        if (!grid.cells.has(key)) grid.cells.set(key, []);
                        grid.cells.get(key).push(i);
                    }
                }
                function neighborIndices(p) {
                    const gx = (p.x / grid.size) | 0;
                    const gy = (p.y / grid.size) | 0;
                    const out = [];
                    for (let y = gy - 1; y <= gy + 1; y++)
                        for (let x = gx - 1; x <= gx + 1; x++) {
                            const arr = grid.cells.get(x + "," + y);
                            if (arr) out.push(...arr);
                        }
                    return out;
                }

                function drawBackground() {
                    ctx.fillStyle = bgGrad; // deep blue-ish
                    ctx.fillRect(0, 0, W, H);

                    // soft vignette for depth
                    const g = ctx.createRadialGradient(
                        W * 0.55,
                        H * 0.4,
                        Math.min(W, H) * 0.05,
                        W * 0.55,
                        H * 0.4,
                        Math.max(W, H) * 0.85
                    );
                    g.addColorStop(0, "rgba(7, 12, 27, 0)");
                    g.addColorStop(1, "rgba(0, 0, 0, 0.7)");
                    ctx.fillStyle = g;
                    ctx.fillRect(0, 0, W, H);
                }

                // Cursor state
                const mouse = { x: -9999, y: -9999, active: false };
                function distToMouse(x, y) {
                    const dx = x - mouse.x,
                        dy = y - mouse.y;
                    return Math.hypot(dx, dy);
                }

                // Main render
                function render(dt) {
                    drawBackground();
                    rebuildGrid();
                    const baseConnect = cfg.connectDist;
                    const nearBoost = mouse.active ? cfg.nearMouseBoost : 1;

                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];
                        p.step(dt);

                        const neigh = neighborIndices(p);
                        let nn1 = null,
                            nn2 = null,
                            d1 = 1e9,
                            d2 = 1e9;

                        const localBoost =
                            mouse.active && distToMouse(p.x, p.y) < 160
                                ? nearBoost
                                : 1;
                        const connectDist = baseConnect * localBoost;

                        for (const j of neigh) {
                            if (j <= i) continue;
                            const q = points[j];
                            const dx = p.x - q.x,
                                dy = p.y - q.y;
                            const d2q = dx * dx + dy * dy;
                            if (d2q > connectDist * connectDist) continue;

                            const d = Math.sqrt(d2q);
                            // record two nearest to form triangles
                            if (d < d1) {
                                d2 = d1;
                                nn2 = nn1;
                                d1 = d;
                                nn1 = q;
                            } else if (d < d2) {
                                d2 = d;
                                nn2 = q;
                            }

                            const alpha = 1 - d / connectDist;
                            ctx.globalAlpha = Math.pow(alpha, 1.8) * 0.9;
                            ctx.strokeStyle =
                                getComputedStyle(
                                    document.documentElement
                                ).getPropertyValue("--blue") || "#1b44ff";
                            ctx.lineWidth = d < cfg.thickDist ? 1.35 : 0.7;
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(q.x, q.y);
                            ctx.stroke();
                        }

                        // glowing node halo
                        const halo = ctx.createRadialGradient(
                            p.x,
                            p.y,
                            0,
                            p.x,
                            p.y,
                            10
                        );
                        halo.addColorStop(0, "rgba(46, 92, 255, 0.55)");
                        halo.addColorStop(1, "rgba(46, 92, 255, 0)");
                        ctx.globalAlpha = 1;
                        ctx.fillStyle = halo;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
                        ctx.fill();

                        // node core
                        ctx.fillStyle =
                            getComputedStyle(
                                document.documentElement
                            ).getPropertyValue("--node") ||
                            "rgba(80,120,255,0.9)";
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, cfg.nodeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // translucent triangular "sails" for an organic mesh feel
                        if (
                            nn1 &&
                            nn2 &&
                            d1 < cfg.triangleDist &&
                            d2 < cfg.triangleDist
                        ) {
                            // area threshold to avoid skinny triangles
                            const area = Math.abs(
                                (nn1.x - p.x) * (nn2.y - p.y) -
                                    (nn2.x - p.x) * (nn1.y - p.y)
                            );
                            if (area > 150) {
                                ctx.globalAlpha = 0.04 + Math.random() * 0.02;
                                ctx.fillStyle =
                                    getComputedStyle(
                                        document.documentElement
                                    ).getPropertyValue("--blue") || "#1b44ff";
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(nn1.x, nn1.y);
                                ctx.lineTo(nn2.x, nn2.y);
                                ctx.closePath();
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }
                        }
                    }

                    // cursor marker (subtle)
                    if (mouse.active) {
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = "#2350ff";
                        ctx.beginPath();
                        ctx.arc(mouse.x, mouse.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }

                // loop
                let last = performance.now();
                let running = true;
                function frame(now) {
                    if (!running) return;
                    const dt = Math.min(0.033, (now - last) / 1000);
                    last = now;
                    render(dt);
                    requestAnimationFrame(frame);
                }

                // interaction
                canvas.addEventListener(
                    "pointermove",
                    (e) => {
                        const rect = canvas.getBoundingClientRect();
                        mouse.x = e.clientX - rect.left;
                        mouse.y = e.clientY - rect.top;
                        mouse.active = true;
                    },
                    { passive: true }
                );
                canvas.addEventListener("pointerleave", () => {
                    mouse.active = false;
                });

                // motion toggle for CPU friendliness
                const toggle = document.getElementById("toggleMotion");
                toggle.addEventListener("change", (e) => {
                    if (e.target.checked) {
                        if (!running) {
                            running = true;
                            last = performance.now();
                            requestAnimationFrame(frame);
                        }
                    } else {
                        running = false;
                    }
                });

                // boot
                window.addEventListener("resize", resize);
                resize();
                if (matchMedia("(prefers-reduced-motion: reduce)").matches) {
                    toggle.checked = false;
                    running = false;
                }
                requestAnimationFrame(frame);
            })();
        </script>
    </body>
</html>
